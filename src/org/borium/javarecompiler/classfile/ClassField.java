package org.borium.javarecompiler.classfile;

import static org.borium.javarecompiler.classfile.ClassFile.*;

import java.util.*;

import org.borium.javarecompiler.classfile.constants.*;

/**
 * Each field is described by a field_info structure. No two fields in one class
 * file may have the same name and descriptor (4.3.2).
 * <p>
 * The structure has the following format:
 *
 * <pre>
	field_info
	{
		u2 access_flags;
		u2 name_index;
		u2 descriptor_index;
		u2 attributes_count;
		attribute_info attributes[attributes_count];
	}
 * </pre>
 */
public class ClassField
{
	/**
	 * The value of the access_flags item is a mask of flags used to denote access
	 * permission to and properties of this field. The interpretation of each flag,
	 * when set, is specified in Table 4.5-A. <table border>
	 * <tr>
	 * <th>Flag Name</th>
	 * <th>Value</th>
	 * <th>Interpretation</th>
	 * </tr>
	 * <tr>
	 * <td>ACC_PUBLIC</td>
	 * <td>0x0001</td>
	 * <td>Declared public; may be accessed from outside its package.
	 * <tr>
	 * <td>ACC_PRIVATE</td>
	 * <td>0x0002</td>
	 * <td>Declared private; accessible only within the defining class and other
	 * classes belonging to the same nest (5.4.4).</td>
	 * <tr>
	 * <tr>
	 * <td>ACC_PROTECTED</td>
	 * <td>0x0004</td>
	 * <td>Declared protected; may be accessed within subclasses.</td>
	 * <tr>
	 * <tr>
	 * <td>ACC_STATIC</td>
	 * <td>0x0008</td>
	 * <td>Declared static.</td>
	 * <tr>
	 * <tr>
	 * <td>ACC_FINAL</td>
	 * <td>0x0010</td>
	 * <td>Declared final; never directly assigned to after object construction (JLS
	 * 17.5).</td>
	 * <tr>
	 * <tr>
	 * <td>ACC_VOLATILE</td>
	 * <td>0x0040</td>
	 * <td>Declared volatile; cannot be cached.</td>
	 * <tr>
	 * <tr>
	 * <td>ACC_TRANSIENT</td>
	 * <td>0x0080</td>
	 * <td>Declared transient; not written or read by a persistent object
	 * manager.</td>
	 * <tr>
	 * <tr>
	 * <td>ACC_SYNTHETIC</td>
	 * <td>0x1000</td>
	 * <td>Declared synthetic; not present in the source code.</td>
	 * <tr>
	 * <tr>
	 * <td>ACC_ENUM</td>
	 * <td>0x4000</td>
	 * <td>Declared as an element of an enum class.</td>
	 * <tr>
	 * </table>
	 * Fields of classes may set any of the flags in Table 4.5-A. However, each
	 * field of a class may have at most one of its ACC_PUBLIC, ACC_PRIVATE, and
	 * ACC_PROTECTED flags set (JLS 8.3.1), and must not have both its ACC_FINAL and
	 * ACC_VOLATILE flags set (JLS 8.3.1.4).
	 * <p>
	 * Fields of interfaces must have their ACC_PUBLIC, ACC_STATIC, and ACC_FINAL
	 * flags set; they may have their ACC_SYNTHETIC flag set and must not have any
	 * of the other flags in Table 4.5-A set (JLS 9.3).
	 * <p>
	 * The ACC_SYNTHETIC flag indicates that this field was generated by a compiler
	 * and does not appear in source code.
	 * <p>
	 * The ACC_ENUM flag indicates that this field is used to hold an element of an
	 * enum class (JLS 8.9).
	 * <p>
	 * All bits of the access_flags item not assigned in Table 4.5-A are reserved
	 * for future use. They should be set to zero in generated class files and
	 * should be ignored by Java Virtual Machine implementations.
	 */
	@SuppressWarnings("unused")
	private int accessFlags;

	/**
	 * The value of the name_index item must be a valid index into the constant_pool
	 * table. The constant_pool entry at that index must be a CONSTANT_Utf8_info
	 * structure (4.4.7) which represents a valid unqualified name denoting a field
	 * (4.2.2).
	 */
	private int nameIndex;

	/**
	 * The value of the descriptor_index item must be a valid index into the
	 * constant_pool table. The constant_pool entry at that index must be a
	 * CONSTANT_Utf8_info structure (4.4.7) which represents a valid field
	 * descriptor (4.3.2).
	 */
	private int descriptorIndex;

	private HashMap<String, ClassAttribute> attributes = new HashMap<>();

	private ArrayList<ClassAttribute> attributeList = new ArrayList<>();

	public void dump(IndentedOutputStream stream, ConstantPool cp)
	{
		stream.println("Field: " + cp.getString(nameIndex) + " " + cp.getString(descriptorIndex));
		stream.indent(1);

		stream.iprint("Access Flags: ");
		stream.printHex(accessFlags, 4);
		int flags = accessFlags;
		flags = printAccessFlag(stream, flags, 0x4000, " Enum");
		flags = printAccessFlag(stream, flags, 0x1000, " Synthetic");
		flags = printAccessFlag(stream, flags, 0x0080, " Transient");
		flags = printAccessFlag(stream, flags, 0x0040, " Volatile");
		flags = printAccessFlag(stream, flags, 0x0010, " Final");
		flags = printAccessFlag(stream, flags, 0x0008, " Static");
		flags = printAccessFlag(stream, flags, 0x0004, " Protected");
		flags = printAccessFlag(stream, flags, 0x0002, " Private");
		flags = printAccessFlag(stream, flags, 0x0001, " Public");
		if (flags != 0)
		{
			stream.print(" Invalid");
			stream.printHex(flags, 4);
		}
		stream.println();

		stream.iprintln("Attributes: " + attributes.size());
		stream.indent(1);
		for (int i = 0; i < attributes.size(); i++)
		{
			ClassAttribute attribute = attributeList.get(i);
			attribute.dump(stream, cp);
		}
		stream.indent(-2);
	}

	public void read(ByteInputStream in, ConstantPool cp)
	{
		accessFlags = in.u2();
		nameIndex = in.u2();
		descriptorIndex = in.u2();
		int attributeCount = in.u2();
		for (int i = 0; i < attributeCount; i++)
		{
			ClassAttribute attribute = ClassAttribute.readAttribute(in, cp);
			attributes.put(attribute.getName(), attribute);
			attributeList.add(attribute);
		}
		// TODO validation
	}
}
